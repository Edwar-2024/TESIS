# -*- coding: utf-8 -*-
"""V8_backend_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fXldPSea7i8S8kKuIdg_QUBaTgY8tCbe
"""

# ================================
# CELDA 1: INSTALACI√ìN DE LIBRER√çAS
# ================================

# Instala el n√∫cleo moderno de LangChain (prompts, mensajes, tools, runnables)
# !pip install -q langchain-core    ## esto solo funciona en colab

# Instala la integraci√≥n oficial con modelos OpenAI (GPT)
#!pip install -q langchain-openai

# Instala componentes comunitarios (conectores, utilidades opcionales)
#!pip install -q langchain-community

# Instala LangGraph (base moderna para agentes; NO usaremos create_react_agent deprecated)
#!pip install -q langgraph

# Driver PostgreSQL para Python (conexi√≥n directa a Postgres)
#!pip install -q psycopg2-binary

# Para exponer el backend en Colab
#!pip install -q fastapi uvicorn nest_asyncio pyngrok

# =========================================
# CELDA 2: CONFIGURACI√ìN DE LA API DE OPENAI
# =========================================

# Importa la librer√≠a est√°ndar de Python para manejar variables de entorno
# Abre el archivo de texto donde guardaste tu API Key
# IMPORTANTE: el archivo solo contiene la clave, nada m√°s
import os
api_key = os.getenv("OPENAI_API_KEY")

# Importaciones principales (MODERNAS, NO DEPRECADAS)
# Modelo de lenguaje GPT a usar
from langchain_openai import ChatOpenAI

# Plantillas de prompts estructurados
from langchain_core.prompts import ChatPromptTemplate

# Mensajes del sistema, usuario y contexto
from langchain_core.messages import HumanMessage, SystemMessage

# Utilidad para definir herramientas personalizadas
from langchain_core.tools import tool

# =========================================
# CELDA 3: INICIALIZACI√ìN DEL MODELO LLM
# =========================================

# Inicializa el modelo GPT
# gpt-3.5-turbo es estable, barato y suficiente para la VERSI√ìN 1
objeto_llm = ChatOpenAI(
    model="gpt-3.5-turbo",
    temperature=0.7   # Controla creatividad (0 = r√≠gido, 1 = m√°s creativo)
)

# =========================================
# CELDA 4: HERRAMIENTA generar_ejercicio EN PSEUDOC√ìDIGO - Es un generador de prompt
# =========================================

from langchain_core.tools import tool

# ---------------------------------------------------------
# Herramienta que genera enunciados en pseudoc√≥digo
# SOLO usa variables relevantes para el LLM
# ---------------------------------------------------------
@tool
def generador_prompt_ejercicio(
    edad: int,
    nivel: str,
    actividad: str,
    tema: str
) -> str:
    """
    Genera un ejercicio en pseudoc√≥digo (NO c√≥digo en un lenguaje real).
    El ejercicio debe ser:
    - Adecuado a la edad del estudiante
    - Ajustado al nivel acad√©mico que puede ser basico, intermedio o avanzado
    - Contextualizado a su actividad favorita
    - Enfocado √∫nicamente en el tema indicado
    No incluye la soluci√≥n.
    """

    return (
        f"Genera un ejercicio en pseudoc√≥digo sobre {tema}, "
        f"nivel {nivel}, para un alumno de {edad} a√±os "
        f"al que le gusta la {actividad}. "
        f"No resuelvas el ejercicio."
    )

"""En la celda 4, simularemos unos datos de entrada y veremos la salida
Entrada
prompt = generador_prompt_ejercicio(
    edad=16,
    nivel="b√°sico",
    actividad="Nataci√≥n",
    tema="Bucles"
)

Salida (texto plano)
"Genera un ejercicio en pseudoc√≥digo sobre Bucles, nivel b√°sico, para un alumno de 16 a√±os al que le gusta la Nataci√≥n. No resuelvas el ejercicio."

"""

# =========================================
# CELDA 5: CREACI√ìN DEL AGENTE EDUCATIVO
# =========================================

from langchain.agents import create_agent

# Prompt del sistema (rol del agente)
prompt_sistema = """
Eres un agente educativo.
Generas √∫nicamente enunciados de ejercicios en PSEUDOC√ìDIGO.
No resuelves los ejercicios.
Debes usar la herramienta generador_prompt_ejercicio.
"""

# Creaci√≥n del agente y enlace con la herramienta creada llamada generador_prompt_ejercicio
agent = create_agent(
    model=objeto_llm,
    tools=[generador_prompt_ejercicio],
    system_prompt=prompt_sistema
)

# =========================================
# CELDA 6: FUNCI√ìN ORQUESTADORA DEL FLUJO PEDAG√ìGICO COMPLETO
# =========================================
# La funcion orquestador_ejercicio no hace nada en su interior, pero permite acceder a los parametros del flujo de datos como historial edad, coloer, etc
# La funcion orquestador_ejercicio no es solo una funci√≥n cualquiera: es como el director de orquesta que organiza toda la informaci√≥n del alumno, decide
# ajustes pedag√≥gicos seg√∫n el historial y prepara el mensaje que va a ‚Äúhablarle‚Äù al LLM. Sin esta funci√≥n, todos esos datos y reglas quedar√≠an desordenados
# y el agente no podr√≠a trabajar de forma coherente.
#
# - La funci√≥n centraliza y gestiona los datos del alumno. Aqui solo existe una funcion que retorna un str, el cual es:  return resultado["messages"][-1].content
# - Controla la adaptaci√≥n pedag√≥gica (sube, baja o mantiene nivel seg√∫n desempe√±o).
# - Construye el prompt para el LLM.
# - Devuelve finalmente el enunciado del ejercicio listo para mostrar al alumno.



def orquestador_ejercicio( edad: int, nivel: str, actividad: str, tema: str, color: str = None, historial: dict = None, solicitar_ayuda: bool = False) -> str:
    """
    Orquesta la generaci√≥n de un ejercicio en pseudoc√≥digo con flujo pedag√≥gico.

    Par√°metros:
    - edad: edad del alumno
    - nivel: 'b√°sico', 'intermedio' o 'avanzado'
    - actividad: actividad favorita del alumno
    - tema: tema de estudio
    - color: color favorito del alumno (opcional, para interfaz)
    - historial: diccionario con desempe√±o previo del alumno (opcional)
    - solicitar_ayuda: si el alumno pide ayuda (opcional)

    Retorna:
    - Enunciado del ejercicio generado por el agente
    """

    # ---------------------------------------------------------
    # 1Ô∏è‚É£ Ajuste pedag√≥gico del nivel
    # ---------------------------------------------------------
    if historial:
        # Si el alumno ha resuelto correctamente los √∫ltimos ejercicios
        exitos = historial.get("ejercicios_correctos", 0)
        fallos = historial.get("ejercicios_fallidos", 0)

        if exitos >= 3 and nivel == "b√°sico":
            nivel = "intermedio"
        elif exitos >= 3 and nivel == "intermedio":
            nivel = "avanzado"
        elif fallos >= 2 and nivel == "intermedio":
            nivel = "b√°sico"
        # Avanzado se mantiene como m√°ximo

    # ---------------------------------------------------------
    # 2Ô∏è‚É£ Construir prompt para el agente
    # ---------------------------------------------------------
    mensaje_usuario = (
        f"Genera un ejercicio en pseudoc√≥digo para un alumno de {edad} a√±os, "
        f"nivel {nivel}, le gusta la {actividad}, sobre {tema}."
    )

    if color:
        mensaje_usuario += f" Su color favorito es {color}."

    if solicitar_ayuda:
        mensaje_usuario += " Incluye pistas o sugerencias para ayudar al alumno."

    entrada_agente = {
        "messages": [
            {"role": "user", "content": mensaje_usuario}
        ]
    }

    # ---------------------------------------------------------
    # 3Ô∏è‚É£ Invocar el agente moderno
    # ---------------------------------------------------------
    resultado = agent.invoke(entrada_agente)

    # ---------------------------------------------------------
    # 4Ô∏è‚É£ Devolver solo el enunciado generado
    # ---------------------------------------------------------
    return resultado["messages"][-1].content

# =========================================
# CELDA 7: CONEXI√ìN A POSTGRESQL (SUPABASE)
# =========================================

import psycopg2
from psycopg2.extras import RealDictCursor

# ---------------------------------------------------------
# Par√°metros de conexi√≥n a Supabase
# (usa los datos que ya verificaste que funcionan)
# ---------------------------------------------------------

DB_HOST = "aws-0-us-west-2.pooler.supabase.com"
DB_PORT = 6543
DB_NAME = "postgres"
DB_USER = "postgres.aoduqewpdufjlptdwkpz"
DB_PASSWORD = "Sistemas=2026"  # ‚Üê NO uses YOUR-PASSWORD

# ---------------------------------------------------------
# Funci√≥n para obtener una conexi√≥n a la base de datos
# ---------------------------------------------------------
def obtener_conexion():
    """
    Crea y devuelve una conexi√≥n activa a PostgreSQL (Supabase).
    Esta funci√≥n ser√° reutilizada por todo el sistema.
    """
    try:
        conexion = psycopg2.connect(
            host=DB_HOST,
            port=DB_PORT,
            dbname=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            cursor_factory=RealDictCursor  # resultados como diccionarios
        )
        return conexion
    except Exception as e:
        print("‚ùå Error al conectar con la base de datos")
        raise e

# Commented out IPython magic to ensure Python compatibility.
# =========================================
# CELDA 8: ACTUALIZACI√ìN DEL PROGRESO ACAD√âMICO
# =========================================
# Esta celda:
# - Registra m√©tricas agregadas del alumno
# - Actualiza progreso POR TEMA
# - Actualiza progreso GLOBAL (tema = 'GLOBAL')
# - Usa SOLO la funci√≥n obtener_conexion()
# - Todas las m√©tricas se calculan UNA SOLA VEZ

from datetime import datetime


def actualizar_progreso_academico(
    alumno_id: int,
    tema: str,
    nivel: str,
    fue_correcto: bool,
    tiempo_intento_segundos: int,
    pidio_ayuda: bool = False,
    tipo_ayuda: str | None = None  ):
    """
    Actualiza la tabla progreso_academico con m√©tricas agregadas.

    Se registran:
    - ejercicios_correctos / fallidos
    - total_intentos
    - total_tiempo_segundos
    - total_ayudas
    - √∫ltimo tipo de ayuda
    - promedios por ejercicio

    Se actualiza:
    - una fila por (alumno, tema)
    - una fila GLOBAL por alumno
    """

    # ---------------------------------------------------------
    # 1Ô∏è‚É£ C√°lculo √öNICO de m√©tricas (regla de oro)
    # ---------------------------------------------------------
    ejercicios_correctos = 1 if fue_correcto else 0
    ejercicios_fallidos  = 0 if fue_correcto else 1
    total_intentos       = 1
    total_ayudas         = 1 if pidio_ayuda else 0
    tiempo_total         = tiempo_intento_segundos
    ahora                = datetime.now()

    # ---------------------------------------------------------
    # 2Ô∏è‚É£ Conexi√≥n a PostgreSQL (Supabase)
    # ---------------------------------------------------------
    conexion = obtener_conexion()
    cursor = conexion.cursor()

    # ---------------------------------------------------------
    # 3Ô∏è‚É£ Funci√≥n interna: UPSERT por tema
    # ---------------------------------------------------------
    def guardar_o_actualizar_progreso(tema_actual: str):
        cursor.execute(
            """
            INSERT INTO progreso_academico (
                alumno_id,
                tema,
                nivel,
                ejercicios_correctos,
                ejercicios_fallidos,
                total_intentos,
                total_tiempo_segundos,
                total_ayudas,
                ultimo_tipo_ayuda,
                promedio_intentos_por_ejercicio,
                promedio_tiempo_por_ejercicio,
                ultima_actualizacion
            )
            VALUES (
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s,
#                 %s
            )
            ON CONFLICT (alumno_id, tema)
            DO UPDATE SET
                ejercicios_correctos = progreso_academico.ejercicios_correctos + %s,
                ejercicios_fallidos  = progreso_academico.ejercicios_fallidos  + %s,
                total_intentos       = progreso_academico.total_intentos + %s,
                total_tiempo_segundos= progreso_academico.total_tiempo_segundos + %s,
                total_ayudas         = progreso_academico.total_ayudas + %s,
                ultimo_tipo_ayuda    = %s,
                promedio_intentos_por_ejercicio =
                    (progreso_academico.total_intentos + %s)::FLOAT /
                    NULLIF(
                        progreso_academico.ejercicios_correctos +
                        progreso_academico.ejercicios_fallidos +
#                         %s + %s, 0
                    ),
                promedio_tiempo_por_ejercicio =
                    (progreso_academico.total_tiempo_segundos + %s)::FLOAT /
                    NULLIF(
                        progreso_academico.ejercicios_correctos +
                        progreso_academico.ejercicios_fallidos +
#                         %s + %s, 0
                    ),
                ultima_actualizacion = %s
            """,
            (
                # INSERT
                alumno_id,
                tema_actual,
                nivel,
                ejercicios_correctos,
                ejercicios_fallidos,
                total_intentos,
                tiempo_total,
                total_ayudas,
                tipo_ayuda,
                float(total_intentos),
                float(tiempo_total),
                ahora,

                # UPDATE
                ejercicios_correctos,
                ejercicios_fallidos,
                total_intentos,
                tiempo_total,
                total_ayudas,
                tipo_ayuda,

                total_intentos,
                ejercicios_correctos,
                ejercicios_fallidos,

                tiempo_total,
                ejercicios_correctos,
                ejercicios_fallidos,

                ahora
            )
        )

    # ---------------------------------------------------------
    # 4Ô∏è‚É£ Actualizar progreso por TEMA
    # ---------------------------------------------------------
    guardar_o_actualizar_progreso(tema)

    # ---------------------------------------------------------
    # 5Ô∏è‚É£ Actualizar progreso GLOBAL del alumno
    # ---------------------------------------------------------
    guardar_o_actualizar_progreso("GLOBAL")

    # ---------------------------------------------------------
    # 6Ô∏è‚É£ Commit y cierre
    # ---------------------------------------------------------
    conexion.commit()
    cursor.close()
    conexion.close()

# =========================================
# CELDA 9: REGISTRO DE INTENTOS DE EJERCICIOS
# (VERSI√ìN NORMALIZADA Y DOCUMENTADA)
# =========================================

from datetime import datetime


def registrar_intento_ejercicio(
    alumno_id: int,
    ejercicio_id: int,
    intento_numero: int,
    fue_correcto: bool,
    tiempo_intento_segundos: int,
    pidio_ayuda: bool = False,
    tipo_ayuda: str | None = None
):
    """
    Registra UN intento del alumno sobre UN ejercicio espec√≠fico.

    üîπ Dise√±o normalizado:
    - No se guarda el enunciado
    - No se repite tema ni nivel
    - Todo eso vive en la tabla ejercicios

    Esta tabla representa eventos at√≥micos (micro-nivel).
    """

    # ---------------------------------------------------------
    # 1Ô∏è‚É£ Timestamps del intento
    # ---------------------------------------------------------
    # Por ahora inicio y fin son el mismo instante.
    # Si luego mides tiempo real desde frontend,
    # aqu√≠ SOLO se ajusta esta parte.
    inicio_intento = datetime.now()
    fin_intento = inicio_intento

    # ---------------------------------------------------------
    # 2Ô∏è‚É£ Conexi√≥n a PostgreSQL (Supabase)
    # ---------------------------------------------------------
    conexion = obtener_conexion()
    cursor = conexion.cursor()

    # ---------------------------------------------------------
    # 3Ô∏è‚É£ Inserci√≥n del evento de intento
    # ---------------------------------------------------------
    # NOTA CLAVE:
    # - ejercicio_id es la FK que conecta con el enunciado
    # - esta tabla NO calcula m√©tricas
    # - SOLO registra hechos
    cursor.execute(
        """
        INSERT INTO historial_ejercicios (
            alumno_id,
            ejercicio_id,
            intento_numero,
            fue_correcto,
            tiempo_intento_segundos,
            pidio_ayuda,
            tipo_ayuda,
            inicio_intento,
            fin_intento
        )
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        """,
        (
            alumno_id,
            ejercicio_id,
            intento_numero,
            fue_correcto,
            tiempo_intento_segundos,
            pidio_ayuda,
            tipo_ayuda,
            inicio_intento,
            fin_intento
        )
    )

    # ---------------------------------------------------------
    # 4Ô∏è‚É£ Commit y cierre
    # ---------------------------------------------------------
    conexion.commit()
    cursor.close()
    conexion.close()

# =========================================
# CELDA 10:
# =========================================
# Objetivo: A partir del estado en progreso_academico, decidir qu√© hacer con el alumno:
# subir nivel
# bajar nivel
# mantener nivel
# recomendar refuerzo
# recomendar avanzar


def decidir_siguiente_paso(alumno_id: int, tema: str):
    """
    -------------------------------------------
    Decide el siguiente paso pedag√≥gico del alumno
    usando la tabla progreso_academico.

    SMP:
    - Sense: lee el estado actual
    - Model: interpreta desempe√±o
    - Plan: decide acci√≥n pedag√≥gica
    """

    conexion = obtener_conexion()
    cursor = conexion.cursor()

    query = """
        SELECT
            nivel,
            ejercicios_correctos,
            ejercicios_fallidos,
            total_intentos,
            total_tiempo_segundos,
            total_ayudas,
            promedio_intentos_por_ejercicio,
            promedio_tiempo_por_ejercicio
        FROM progreso_academico
        WHERE alumno_id = %s
          AND tema = %s
        LIMIT 1;
    """

    cursor.execute(query, (alumno_id, tema))
    registro = cursor.fetchone()

    cursor.close()
    conexion.close()

    # Si no hay datos a√∫n
    if registro is None:
        return {
            "accion": "iniciar",
            "mensaje": "Alumno inicia en nivel b√°sico",
            "nivel_sugerido": "b√°sico"
        }

    # -----------------------------
    # MODELO (interpretaci√≥n)
    # -----------------------------
    correctos = registro["ejercicios_correctos"]
    fallidos = registro["ejercicios_fallidos"]
    intentos = registro["total_intentos"]
    ayudas = registro["total_ayudas"]
    nivel_actual = registro["nivel"]

    if intentos == 0:
        tasa_exito = 0
    else:
        tasa_exito = correctos / intentos

    # -----------------------------
    # PLAN (reglas pedag√≥gicas)
    # -----------------------------

    # Caso 1: desempe√±o alto ‚Üí subir nivel
    if tasa_exito >= 0.8 and ayudas == 0:
        return {
            "accion": "avanzar",
            "mensaje": "Alto desempe√±o, puede subir de nivel",
            "nivel_actual": nivel_actual,
            "nivel_sugerido": "intermedio" if nivel_actual == "b√°sico" else "avanzado"
        }

    # Caso 2: muchos fallos ‚Üí reforzar
    if fallidos >= correctos:
        return {
            "accion": "reforzar",
            "mensaje": "Se recomienda refuerzo y ejercicios guiados",
            "nivel_actual": nivel_actual,
            "nivel_sugerido": nivel_actual
        }

    # Caso 3: muchas ayudas ‚Üí mantener nivel
    if ayudas >= intentos * 0.5:
        return {
            "accion": "mantener",
            "mensaje": "Mantener nivel con apoyo gradual",
            "nivel_actual": nivel_actual,
            "nivel_sugerido": nivel_actual
        }

    # Caso 4: progreso normal
    return {
        "accion": "continuar",
        "mensaje": "Continuar con ejercicios del mismo nivel",
        "nivel_actual": nivel_actual,
        "nivel_sugerido": nivel_actual
    }

# =========================================
# CELDA 11: ORQUESTADOR MANAGER
# (VERSI√ìN NORMALIZADA Y COHERENTE CON BD)
# =========================================

def orquestador_manager(alumno_id: int, tema: str, edad: int, actividad: str):
    """
    Orquesta el flujo pedag√≥gico COMPLETO para un alumno y un tema.

    Integra:
    - Decisi√≥n pedag√≥gica (SMP)
    - Generaci√≥n del ejercicio (LLM)
    - Persistencia del ejercicio (tabla ejercicios)

    ‚ùó IMPORTANTE:
    Esta funci√≥n NO registra intentos.
    SOLO crea el ejercicio.
    """

    # ---------------------------------------------------------
    # 1Ô∏è‚É£ DECISI√ìN PEDAG√ìGICA (SMP - Sense / Model / Plan)
    # ---------------------------------------------------------
    decision = decidir_siguiente_paso(alumno_id, tema)

    accion = decision["accion"]
    nivel_sugerido = decision["nivel_sugerido"]

    print(f"[INFO] Acci√≥n: {accion} | Nivel: {nivel_sugerido}")

    # ---------------------------------------------------------
    # 2Ô∏è‚É£ Si NO corresponde generar ejercicio, se detiene
    # ---------------------------------------------------------
    if accion not in ["iniciar", "avanzar", "continuar"]:
        return {
            "decision": decision,
            "ejercicio_id": None,
            "enunciado": None
        }

    # ---------------------------------------------------------
    # 3Ô∏è‚É£ Generaci√≥n del ejercicio con el agente educativo
    # ---------------------------------------------------------
    # Aqu√≠ SOLO se genera texto.
    # No se guarda a√∫n.
    enunciado = orquestador_ejercicio(
        edad=edad,
        nivel=nivel_sugerido,
        actividad=actividad,
        tema=tema
    )

    # ---------------------------------------------------------
    # 4Ô∏è‚É£ Persistencia del ejercicio (tabla ejercicios)
    # ---------------------------------------------------------
    # Este paso permite:
    # - evitar repetir enunciados
    # - reutilizar el ejercicio
    # - vincular m√∫ltiples intentos
    conexion = obtener_conexion()
    cursor = conexion.cursor()

    cursor.execute(
        """
        INSERT INTO ejercicios (
            tema,
            nivel,
            enunciado
        )
        VALUES (%s, %s, %s)
        RETURNING id
        """,
        (tema, nivel_sugerido, enunciado)
    )

    # Se obtiene el ID del ejercicio reci√©n creado
    ejercicio_id = cursor.fetchone()["id"]

    conexion.commit()
    cursor.close()
    conexion.close()

    # ---------------------------------------------------------
    # 5Ô∏è‚É£ Retorno al sistema / frontend
    # ---------------------------------------------------------
    return {
        "decision": decision,
        "ejercicio_id": ejercicio_id,
        "enunciado": enunciado
    }

# =========================================
# CELDA 12: FLUJO COMPLETO DE UN INTENTO
# =========================================
# Esta celda representa el "caso real":
# 1. El sistema ya gener√≥ un ejercicio (CELDA 11)
# 2. El alumno intenta resolverlo
# 3. Se registra el intento (micro-nivel)
# 4. Se actualiza el progreso acad√©mico (macro-nivel)

def procesar_intento_completo(
    alumno_id: int,
    ejercicio_id: int,
    tema: str,
    nivel: str,
    fue_correcto: bool,
    tiempo_intento_segundos: int,
    pidio_ayuda: bool = False,
    tipo_ayuda: str | None = None,
    intento_numero: int = 1
):
    """
    Procesa un intento REAL de un alumno sobre un ejercicio.

    Esta funci√≥n:
    - NO genera ejercicios
    - NO decide pedagog√≠a
    - SOLO registra hechos y m√©tricas

    Es clave para:
    - trazabilidad
    - an√°lisis estad√≠stico
    - exportaci√≥n de datos para la tesis
    """

    # ---------------------------------------------------------
    # 1Ô∏è‚É£ Registrar intento individual (tabla historial_ejercicios)
    # ---------------------------------------------------------
    # Nivel MICRO: cada acci√≥n del alumno queda registrada. Llama a laa funcion registrar_intento_ejercicio
    registrar_intento_ejercicio(
        alumno_id=alumno_id,
        ejercicio_id=ejercicio_id,
        intento_numero=intento_numero,
        fue_correcto=fue_correcto,
        tiempo_intento_segundos=tiempo_intento_segundos,
        pidio_ayuda=pidio_ayuda,
        tipo_ayuda=tipo_ayuda
    )

    # ---------------------------------------------------------
    # 2Ô∏è‚É£ Actualizar progreso acad√©mico agregado
    # ---------------------------------------------------------
    # Nivel MACRO: m√©tricas acumuladas por tema y global. LLama a la funcion actualizar_progreso_academico
    actualizar_progreso_academico(
        alumno_id=alumno_id,
        tema=tema,
        nivel=nivel,
        fue_correcto=fue_correcto,
        tiempo_intento_segundos=tiempo_intento_segundos,
        pidio_ayuda=pidio_ayuda,
        tipo_ayuda=tipo_ayuda
    )

    # ---------------------------------------------------------
    # 3Ô∏è‚É£ Retorno de confirmaci√≥n (√∫til para frontend / logs)
    # ---------------------------------------------------------
    return {
        "status": "ok",
        "alumno_id": alumno_id,
        "ejercicio_id": ejercicio_id,
        "intento_numero": intento_numero,
        "fue_correcto": fue_correcto,
        "tiempo": tiempo_intento_segundos,
        "pidio_ayuda": pidio_ayuda
    }

# =========================================
# CELDA 13: CIERRE DE APRENDIZAJE
# =========================================
# Esta celda:
# - Cierra un intento del alumno
# - Consulta el ejercicio REAL desde la BD
# - Registra el intento (micro)
# - Actualiza el progreso acad√©mico (macro)
# =========================================

from datetime import datetime

def cerrar_intento_aprendizaje(
    alumno_id: int,
    ejercicio_id: int,
    intento_numero: int,
    fue_correcto: bool,
    tiempo_intento_segundos: int,
    pidio_ayuda: bool = False,
    tipo_ayuda: str | None = None
):
    """
    Cierra un intento de aprendizaje del alumno.

    Flujo:
    1. Obtiene datos del ejercicio (tema, nivel)
    2. Registra intento en historial_ejercicios
    3. Actualiza progreso_academico
    """

    conexion = obtener_conexion()
    cursor = conexion.cursor()

    # -------------------------------------------------
    # 1Ô∏è‚É£ Obtener datos del ejercicio (FUENTE DE VERDAD)
    # -------------------------------------------------
    cursor.execute(
        """
        SELECT id, tema, nivel
        FROM ejercicios
        WHERE id = %s
        LIMIT 1
        """,
        (ejercicio_id,)
    )

    ejercicio = cursor.fetchone()

    if ejercicio is None:
        cursor.close()
        conexion.close()
        raise ValueError(f"Ejercicio con ID {ejercicio_id} no existe")

    tema = ejercicio["tema"]
    nivel = ejercicio["nivel"]

    # -------------------------------------------------
    # 2Ô∏è‚É£ Registrar intento (MICRO NIVEL)
    # -------------------------------------------------
    fin_intento = datetime.now()
    inicio_intento = fin_intento  # simplificado

    cursor.execute(
        """
        INSERT INTO historial_ejercicios (
            alumno_id,
            ejercicio_id,
            intento_numero,
            fue_correcto,
            tiempo_intento_segundos,
            pidio_ayuda,
            tipo_ayuda,
            inicio_intento,
            fin_intento
        )
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
        """,
        (
            alumno_id,
            ejercicio_id,
            intento_numero,
            fue_correcto,
            tiempo_intento_segundos,
            pidio_ayuda,
            tipo_ayuda,
            inicio_intento,
            fin_intento
        )
    )

    # -------------------------------------------------
    # 3Ô∏è‚É£ Actualizar progreso acad√©mico (MACRO NIVEL)
    # -------------------------------------------------
    actualizar_progreso_academico(
        alumno_id=alumno_id,
        tema=tema,
        nivel=nivel,
        fue_correcto=fue_correcto,
        tiempo_intento_segundos=tiempo_intento_segundos,
        pidio_ayuda=pidio_ayuda,
        tipo_ayuda=tipo_ayuda
    )

    conexion.commit()
    cursor.close()
    conexion.close()

    return {
        "estado": "ok",
        "alumno_id": alumno_id,
        "ejercicio_id": ejercicio_id,
        "tema": tema,
        "nivel": nivel,
        "fue_correcto": fue_correcto
    }

# ==============================
# CELDA 14 ‚Äì ORQUESTADOR PEDAG√ìGICO COMPLETO (VERSI√ìN DEPURABLE)
# ==============================
# Objetivo:
# - Integrar cierre de intento (CELDA 13)
# - Decisi√≥n pedag√≥gica SMP (CELDA 10)
# - Generaci√≥n de nuevo ejercicio adaptativo (CELDA 6)
# - Retornar decisi√≥n pedag√≥gica + ejercicio generado + flags de ayuda
# - Esta celda representa el AGENTE PEDAG√ìGICO completo

def orquestador_pedagogico(
    alumno_id: int,
    ejercicio_id: int,
    intento_numero: int,
    fue_correcto: bool,
    tiempo_intento_segundos: int,
    edad: int,
    actividad: str,
    pidio_ayuda: bool = False,
    tipo_ayuda: str | None = None
):
    """
    Orquesta todo el flujo pedag√≥gico de un alumno.

    Flujo:
    1Ô∏è‚É£ Cierra intento anterior y actualiza progreso (CELDA 13)
    2Ô∏è‚É£ Eval√∫a desempe√±o y decide acci√≥n pedag√≥gica (SMP - CELDA 10)
    3Ô∏è‚É£ Genera nuevo ejercicio si corresponde (CELDA 6)
    4Ô∏è‚É£ Persiste el ejercicio en la BD
    """

    # 1Ô∏è‚É£ Cierre del intento actual (MICRO + MACRO)
    cierre = cerrar_intento_aprendizaje(
        alumno_id=alumno_id,
        ejercicio_id=ejercicio_id,
        intento_numero=intento_numero,
        fue_correcto=fue_correcto,
        tiempo_intento_segundos=tiempo_intento_segundos,
        pidio_ayuda=pidio_ayuda,
        tipo_ayuda=tipo_ayuda
    )

    # 2Ô∏è‚É£ Leer tema y nivel del ejercicio cerrado
    tema = cierre["tema"]
    nivel_actual = cierre["nivel"]

    # 3Ô∏è‚É£ Decidir siguiente paso pedag√≥gico (SMP)
    decision = decidir_siguiente_paso(alumno_id, tema)
    accion = decision.get("accion", None)
    nivel_sugerido = decision.get("nivel_sugerido", nivel_actual)

    # 4Ô∏è‚É£ Inicializar variables de resultado
    nuevo_ejercicio_id = None
    enunciado = None
    ayuda_incluida = False

    # 5Ô∏è‚É£ Generar nuevo ejercicio SOLO si la acci√≥n lo requiere
    if accion in ["iniciar", "avanzar", "continuar"]:
        # Determinar si incluir ayuda seg√∫n reglas
        incluir_ayuda = False
        if accion == "iniciar":
            incluir_ayuda = True   # alumno nuevo siempre recibe gu√≠a
        elif pidio_ayuda or decision.get("accion") == "reforzar":
            incluir_ayuda = True

        ayuda_incluida = incluir_ayuda

        # Llamada al agente educativo (CELDA 6)
        enunciado = orquestador_ejercicio(
            edad=edad,
            nivel=nivel_sugerido,
            actividad=actividad,
            tema=tema,
            solicitar_ayuda=incluir_ayuda
        )

        # Persistencia del ejercicio (tabla ejercicios)
        conexion = obtener_conexion()
        cursor = conexion.cursor()
        cursor.execute(
            """
            INSERT INTO ejercicios (tema, nivel, enunciado)
            VALUES (%s, %s, %s)
            RETURNING id
            """,
            (tema, nivel_sugerido, enunciado)
        )
        nuevo_ejercicio_id = cursor.fetchone()["id"]
        conexion.commit()
        cursor.close()
        conexion.close()

    # 6Ô∏è‚É£ Retornar estructura completa del flujo pedag√≥gico
    return {
        "cierre_intento": cierre,              # resultado de CELDA 13
        "decision_pedagogica": decision,      # resultado de CELDA 10
        "nuevo_ejercicio_id": nuevo_ejercicio_id,
        "enunciado": enunciado,
        "ayuda_incluida": ayuda_incluida
    }
